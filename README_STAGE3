

---- MARKING RUBRIC ----

.5 - Compiles & Runs
- Yeahhh boi
- https://youtu.be/M6ieVxb11Ms
- Video attatched to project

Behavioural Design Pattern
Planned on useing the following... However, I ran out of time.
- Maybe some points for extending existing design patters? :P
- Strategy: handle game state & player state (using switch statemets, too much coupling)
- Memento: save and restore levels from checkpoints at the moment this is all pretty heavily couplesd


1.0 - Code Quality
- Meaningful usernames used
- Separated functions into helper functions in order to reduce complexity of each function

1.0 - Configurable # of lives
- Lives configureable in config file

1.0 - Level Restarts on loss of life
- Enemies restart
- Player returns to starting x coordinate
- Score reduces to the score at the beginning of the level

1.0 - Scoring system
- score increments at a slower rate
- +100 points when object is 'killed' from above
- +1,000 multiplied by current level when level is completed
- +1,000,000 for reaching the end of the screen before enemies have all run out

1.0 - Preservation of previous functionality
- *takes glasses off* YEAHHHHHHHHHHH

0.75 - User controls stickman (0.75)
- Enemies, background and stickment travel at different rates
- User moves left and right
- Rate of enemies adjust to account for speed of user

1.0 - Multiple Levels
- Unlimited levels
- 2 Levels at the moment. Half obstacles specified are stage 1, other half are stage 2
- Easily extendable for multiple levels
- Level1: Cacti moves at same speed as background
- Level2+: Birds with configurable velocity
- Game speeds up with each level but user stays the same

1.0 - Memory efficient design
- yeah boi! No memory is direcly created or deleted throughout the new code
- all forced deletions are designed to be triggered by existing render functions

0.75 - Powerups
- Get a powerup by 'killing' an enemy
- Toggle through each size mode
- This is designed to be used as a strategy as different modes will have different powers
--> Giant cannot jump but is indestructable: as a result scoring is slower, still gets pushed back each time
--> As Giant cannot jump, Giant cannot willingly change mode, 1 in 4 chance of chaning modes when killing enemies
--> Large has an extra jump
--> Tiny is smaller and can fit in smaller spaces
--> Normal (well thats just normal)

1.75 - Sensible Testing Framework
- stage 3 collision testing
- giant walking through enemies
- kill obstacles by jumping on them
- changing modes / sizes
- checking set and getters for number of lives work

~1.0 Extensions
- Gain / lose space (ie pushed back by enemies or push them back)
--> fed into game mechanic (can lose by getting pushed back to far or win early by reaching the end, stickman can pass level before all obstacles are complete by reaching the end)
- Stage 1 code preserved (ie different types obstacles for level 1 & for level 2)
- Unlimited levels
--> Speed increases with each levels


Notes & conclusion
- Still quite a bit of classes which are highly coupled
- Wrote functional code as the first goal with the idea of refactoring later
- Refactoring turned out to be very hard and it would have been better to either design the code with the design patterns in mind or to regurlarly refactor code
- Waiting to do it all at the end proved to be too much
